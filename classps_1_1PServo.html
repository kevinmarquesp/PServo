<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PServo: ps::PServo Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PServo<span id="projectnumber">&#160;v0.2.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceps.html">ps</a></li><li class="navelem"><a class="el" href="classps_1_1PServo.html">PServo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classps_1_1PServo-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ps::PServo Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="PServo_8h_source.html">PServo.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa1c7e663f4ddb9a6ee4829aae13f5cf6" id="r_aa1c7e663f4ddb9a6ee4829aae13f5cf6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1c7e663f4ddb9a6ee4829aae13f5cf6">PServo</a> (unsigned long *const timer)</td></tr>
<tr class="separator:aa1c7e663f4ddb9a6ee4829aae13f5cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade4e2a48186cdee0e15ccdd1036b486" id="r_aade4e2a48186cdee0e15ccdd1036b486"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aade4e2a48186cdee0e15ccdd1036b486">PServo</a> (unsigned long *const timer, bool const is_resetable)</td></tr>
<tr class="separator:aade4e2a48186cdee0e15ccdd1036b486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af797d7b3f4f0bb69e23ec656b095ad61" id="r_af797d7b3f4f0bb69e23ec656b095ad61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af797d7b3f4f0bb69e23ec656b095ad61">PServo</a> (unsigned long *const timer, unsigned char const min, unsigned char const max)</td></tr>
<tr class="separator:af797d7b3f4f0bb69e23ec656b095ad61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188cf28801ca0ab2710336dcd3ac1114" id="r_a188cf28801ca0ab2710336dcd3ac1114"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a188cf28801ca0ab2710336dcd3ac1114">PServo</a> (unsigned long *const timer, unsigned char const min, unsigned char const max, bool const is_resetable)</td></tr>
<tr class="separator:a188cf28801ca0ab2710336dcd3ac1114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2571040d0a2f38d72a44c8c75960939" id="r_ad2571040d0a2f38d72a44c8c75960939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classps_1_1PServo.html">PServo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2571040d0a2f38d72a44c8c75960939">begin</a> (void)</td></tr>
<tr class="separator:ad2571040d0a2f38d72a44c8c75960939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa578414a8fecab47c582bc5b49e4af3a" id="r_aa578414a8fecab47c582bc5b49e4af3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classps_1_1PServo.html">PServo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa578414a8fecab47c582bc5b49e4af3a">move</a> (unsigned char const next_pos)</td></tr>
<tr class="separator:aa578414a8fecab47c582bc5b49e4af3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50231afb3e2f61d7fb961d99a66b849" id="r_ac50231afb3e2f61d7fb961d99a66b849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classps_1_1PServo.html">PServo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac50231afb3e2f61d7fb961d99a66b849">move</a> (unsigned char const next_pos, unsigned short const delay)</td></tr>
<tr class="separator:ac50231afb3e2f61d7fb961d99a66b849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83036e8f1b99b2e35245275ac85fea6" id="r_af83036e8f1b99b2e35245275ac85fea6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structps_1_1Props.html">Props</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af83036e8f1b99b2e35245275ac85fea6">get_props</a> (void) const</td></tr>
<tr class="separator:af83036e8f1b99b2e35245275ac85fea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad190be2230cc6d115f4b4f2f8e3c4d3a" id="r_ad190be2230cc6d115f4b4f2f8e3c4d3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceps.html#ad6e4db5c52b1a0b70eb8002dd6045e78">State</a> const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad190be2230cc6d115f4b4f2f8e3c4d3a">get_state</a> (void) const</td></tr>
<tr class="separator:ad190be2230cc6d115f4b4f2f8e3c4d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main class of the library, represents the <b>state machine</b> of an asyncronous servo motor object. Which means that this can hold the position (in deg) inside it, so you can get use that information to wirte in a real servo motor component.</p>
<p>Since it uses an asyncronous logic, you need to pass the reference of an counter, and this counter should be be updated every loop iteration (see the example).</p>
<p>The logic to make it work is quite simple, start with the <code>PServo::being()</code> call, so it knows where set of movements needs to stop and start other for each loop, then put your sequence of movements that you want to perform one after another. This machine is smart enough to figure out which movement should be executed and which should be just ignored.</p>
<p>For an example: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> timer = 0;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classps_1_1PServo.html">ps::PServo</a> myservo_machine(&amp;timer);</div>
<div class="line">Servo myservo;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">  Servo.attach(8);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> loop() {</div>
<div class="line">  timer = millis();</div>
<div class="line"> </div>
<div class="line">  myservo.write(myservo_machine.get_props().pos);</div>
<div class="line"> </div>
<div class="line">  myservo_machine.begin()</div>
<div class="line">    -&gt;move(90, 10)</div>
<div class="line">    -&gt;move(180, 25)</div>
<div class="line">    -&gt;move(0, 5);</div>
<div class="line">}</div>
<div class="ttc" id="aclassps_1_1PServo_html"><div class="ttname"><a href="classps_1_1PServo.html">ps::PServo</a></div><div class="ttdef"><b>Definition</b> PServo.h:143</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="structps_1_1Props.html">ps::Props</a> </dd>
<dd>
<a class="el" href="namespaceps.html#ad6e4db5c52b1a0b70eb8002dd6045e78">ps::State</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa1c7e663f4ddb9a6ee4829aae13f5cf6" name="aa1c7e663f4ddb9a6ee4829aae13f5cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c7e663f4ddb9a6ee4829aae13f5cf6">&#9670;&#160;</a></span>PServo() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ps::PServo::PServo </td>
          <td>(</td>
          <td class="paramtype">unsigned long *const</td>          <td class="paramname"><span class="paramname"><em>timer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The constructor need, at least, a pointer to a <b>timer</b> variable. This variable, normally, is a global one, that multiple state machines can read to calculate the delay asynchronously.</p>
<p>For an example, at the top of your main Arduino sketch file, you may have a <code>unsigned long timer = 0;</code> line, then, inside the <code>loop()</code> function, you'll update that variable value everytime with the <code>millis()</code> function &ndash; which will return the time duration since your Arduino board was booted up, in milisseconds.</p>
<p>For an example: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> timer = 0;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classps_1_1PServo.html">ps::PServo</a> myservo_machine(&amp;timer);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">  <span class="comment">// Your setup code...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> loop() {</div>
<div class="line">  timer = millis();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Your loop code...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>This choice was made because every pointer in C++ uses 16 bits of memory all the time, and an <code>unsigned long</code> uses 64 bits, which is much havier, mainly when dealing with multiple object instances of this class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>Pointer to a timer variable, normally related to the <code>millis()</code> function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classps_1_1PServo.html">ps::PServo</a> </dd></dl>

</div>
</div>
<a id="aade4e2a48186cdee0e15ccdd1036b486" name="aade4e2a48186cdee0e15ccdd1036b486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade4e2a48186cdee0e15ccdd1036b486">&#9670;&#160;</a></span>PServo() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ps::PServo::PServo </td>
          <td>(</td>
          <td class="paramtype">unsigned long *const</td>          <td class="paramname"><span class="paramname"><em>timer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const</td>          <td class="paramname"><span class="paramname"><em>is_resetable</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The constructor need, at least, a pointer to a <b>timer</b> variable. This variable, normally, is a global one, that multiple state machines can read to calculate the delay asynchronously.</p>
<p>You can also pass the reset setting, a <em>bolean</em> type parameter, to the constructor. By default, the machine will not reset after the last action completion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>Pointer to a timer variable, normally related to the <code>millis()</code> function. </td></tr>
    <tr><td class="paramname">is_resetable</td><td>Configure the machine to reset after it's halted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af797d7b3f4f0bb69e23ec656b095ad61" name="af797d7b3f4f0bb69e23ec656b095ad61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af797d7b3f4f0bb69e23ec656b095ad61">&#9670;&#160;</a></span>PServo() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ps::PServo::PServo </td>
          <td>(</td>
          <td class="paramtype">unsigned long *const</td>          <td class="paramname"><span class="paramname"><em>timer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char const</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char const</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The constructor need, at least, a pointer to a <b>timer</b> variable. This variable, normally, is a global one, that multiple state machines can read to calculate the delay asynchronously.</p>
<p>If needed, you can also configure the <b>max</b> and <b>min</b> position that this machine can assume. It's quite useful when your building a robot, as an example, that some movements can break the structure of the robot phisically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>Pointer to a timer variable, normally related to the <code>millis()</code> function. </td></tr>
    <tr><td class="paramname">min</td><td>Minimul position value that this machine can be. </td></tr>
    <tr><td class="paramname">max</td><td>Maximum position value that this machine can be.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceps_1_1Default.html">ps::Default</a> </dd></dl>

</div>
</div>
<a id="a188cf28801ca0ab2710336dcd3ac1114" name="a188cf28801ca0ab2710336dcd3ac1114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188cf28801ca0ab2710336dcd3ac1114">&#9670;&#160;</a></span>PServo() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ps::PServo::PServo </td>
          <td>(</td>
          <td class="paramtype">unsigned long *const</td>          <td class="paramname"><span class="paramname"><em>timer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char const</td>          <td class="paramname"><span class="paramname"><em>min</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char const</td>          <td class="paramname"><span class="paramname"><em>max</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const</td>          <td class="paramname"><span class="paramname"><em>is_resetable</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The constructor need, at least, a pointer to a <b>timer</b> variable. This variable, normally, is a global one, that multiple state machines can read to calculate the delay asynchronously.</p>
<p>And for more advanced configuration, or verbosity, you can combine the other constructors into just this one. Where you pass the timer pointer, the min-max values and the seeting to define if this machine should reset to the first movement after done or not!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>Pointer to a timer variable, normally related to the <code>millis()</code> function. </td></tr>
    <tr><td class="paramname">min</td><td>Minimul position value that this machine can be. </td></tr>
    <tr><td class="paramname">max</td><td>Maximum position value that this machine can be. </td></tr>
    <tr><td class="paramname">is_resetable</td><td>Configure the machine to reset after it's halted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceps_1_1Default.html">ps::Default</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad2571040d0a2f38d72a44c8c75960939" name="ad2571040d0a2f38d72a44c8c75960939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2571040d0a2f38d72a44c8c75960939">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classps_1_1PServo.html">ps::PServo</a> * ps::PServo::begin </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the most important one, it should be used everytime at the beginning of a move set collection, that's because it will handle most of the possible states of this machine &ndash; such as count the number of actions it should take on the first call or check if the machine should halt or start over again.</p>
<p>The reason this function, and the others, returns a pointer reference of the this same object class is to help you write sets of movements without so much code repetition. It is a <em>syntax sugar</em>, if you will.</p>
<p>For example, instead of doing this: </p><div class="fragment"><div class="line">myservo_machine.begin();</div>
<div class="line">myservo_machine.move(90, 10);</div>
<div class="line">myservo_machine.move(180, 50);</div>
<div class="line">myservo_machine.move(0, 30);</div>
</div><!-- fragment --><p>You can simply do: </p><div class="fragment"><div class="line">myservo_machine.begin()</div>
<div class="line">  -&gt;move(90, 10)</div>
<div class="line">  -&gt;move(180, 50)</div>
<div class="line">  -&gt;move(0, 30);</div>
</div><!-- fragment --><p>Since this function is asynchronous, it <b>should be called every time in the <code>loop()</code> function</b>! That's because it uses the <code>_timer</code> value &ndash; defined in this class constructor &ndash; to calculate how when the current servo position should be updated.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to this same object, allowing the use of the <code>-&gt;</code> syntax to write a stream of actions that this state machine will perform. </dd></dl>

</div>
</div>
<a id="af83036e8f1b99b2e35245275ac85fea6" name="af83036e8f1b99b2e35245275ac85fea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83036e8f1b99b2e35245275ac85fea6">&#9670;&#160;</a></span>get_props()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structps_1_1Props.html">ps::Props</a> const ps::PServo::get_props </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method allows the user to inspect all the private attributes of the object. It's quite useful for loggin or monitoring sketches, or maybe to build more complex sketches that behaves differently depending of the state of this object.</p>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structps_1_1Props.html">ps::Props</a></code> struct with all the private members values of the instantiated object. </dd></dl>

</div>
</div>
<a id="ad190be2230cc6d115f4b4f2f8e3c4d3a" name="ad190be2230cc6d115f4b4f2f8e3c4d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad190be2230cc6d115f4b4f2f8e3c4d3a">&#9670;&#160;</a></span>get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceps.html#ad6e4db5c52b1a0b70eb8002dd6045e78">ps::State</a> const ps::PServo::get_state </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to know which state the machine is currently in. Used to catch state and handle state errors or build complex systems that behaves differently based on the state of this machine.</p>
<dl class="section return"><dt>Returns</dt><dd>The current state of the machine. </dd></dl>

</div>
</div>
<a id="aa578414a8fecab47c582bc5b49e4af3a" name="aa578414a8fecab47c582bc5b49e4af3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa578414a8fecab47c582bc5b49e4af3a">&#9670;&#160;</a></span>move() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classps_1_1PServo.html">ps::PServo</a> * ps::PServo::move </td>
          <td>(</td>
          <td class="paramtype">unsigned char const</td>          <td class="paramname"><span class="paramname"><em>next_pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function just calls it self again, but passing the <code><a class="el" href="namespaceps_1_1Default.html#ada16a56962d5f9caa8bc9a5394c8c1c0" title="Default delay between movement updates.">ps::Default::DELAY</a></code> as a seccodary parameter to move (or, in this context, update the value of the <code>_pos</code> private attribute) is a specific speed.</p>
<p>This function overload can be helpful because, in some cases, is necessary to just move the servo motors in an asynchronous way. So it helps to write less code and be more descriptve of <b>what</b> you want to do and not <b>how</b>.</p>
<p>Check for more details the explaination of the full version of this function call, the one that you need to specify the movement speed too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_pos</td><td>Next position that it needs to move to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to this same object, allowing the use of the <code>-&gt;</code> syntax to write a stream of actions that this state machine will perform. </dd></dl>

</div>
</div>
<a id="ac50231afb3e2f61d7fb961d99a66b849" name="ac50231afb3e2f61d7fb961d99a66b849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50231afb3e2f61d7fb961d99a66b849">&#9670;&#160;</a></span>move() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classps_1_1PServo.html">ps::PServo</a> * ps::PServo::move </td>
          <td>(</td>
          <td class="paramtype">unsigned char const</td>          <td class="paramname"><span class="paramname"><em>next_pos</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short const</td>          <td class="paramname"><span class="paramname"><em>delay</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method will start the <b>movement</b> action, it only works if the machine is in the <code><a class="el" href="namespaceps.html#ad6e4db5c52b1a0b70eb8002dd6045e78a70ef66c5a6820db89c2d997cf49dd43e" title="Will keep updating the servo&#39;s position.">ps::State::IN_ACTION</a></code>, otherwise, it will perform nothing.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Note</b>: In <code><a class="el" href="namespaceps.html#ad6e4db5c52b1a0b70eb8002dd6045e78adee5f03c2c4e73657824e028494b18c0" title="Measn that the actions was counted, so start it!">ps::State::INITIALIZED</a></code> mode, it will, actually, count the movement. This is because the first run of the move set is for determining how much moves it should do before halt/reset. </p>
</blockquote>
<p>The <code>delay</code> paramter is not the overall duration of the movement! It is, actually, the delay between each degree from the the current position to the next one. For an example, if you're at <code>0</code> and want to go to <code>180</code> with <code>10</code> for delay, the overall duration will be <code>1.8</code> seconds.</p>
<p>Since this function is asynchronous, it <b>should be called every time in the <code>loop()</code> function</b>! That's because it uses the <code>_timer</code> value &ndash; defined in this class constructor &ndash; to calculate how when the current servo position should be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_pos</td><td>Next position that it needs to move to. </td></tr>
    <tr><td class="paramname">delay</td><td>Delay between each position increment, until it's done.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to this same object, allowing the use of the <code>-&gt;</code> syntax to write a stream of actions that this state machine will perform. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="PServo_8h_source.html">PServo.h</a></li>
<li>src/<b>PServo.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
